from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel, Field
import uuid

from ..database import get_db
from ..models import Diagnosis, PlantCondition, Plant, User
from ..services import auth_service, diagnosis_service

router = APIRouter()

# Pydantic models for request/response
class PlantConditionBase(BaseModel):
    name: str
    name_ar: Optional[str] = None
    description: Optional[str] = None
    description_ar: Optional[str] = None
    treatment: Optional[str] = None
    treatment_ar: Optional[str] = None
    prevention: Optional[str] = None
    prevention_ar: Optional[str] = None

class PlantConditionCreate(PlantConditionBase):
    pass

class PlantConditionResponse(PlantConditionBase):
    id: str
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        orm_mode = True

class DiagnosisBase(BaseModel):
    plant_id: Optional[str] = None
    condition_id: Optional[str] = None
    confidence_score: Optional[float] = None
    notes: Optional[str] = None
    notes_ar: Optional[str] = None

class DiagnosisCreate(DiagnosisBase):
    pass

class DiagnosisResponse(DiagnosisBase):
    id: str
    user_id: str
    image_url: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    condition: Optional[PlantConditionResponse] = None
    
    class Config:
        orm_mode = True

# Routes
@router.post("/", response_model=DiagnosisResponse, status_code=status.HTTP_201_CREATED)
async def create_diagnosis(
    file: UploadFile = File(...),
    plant_id: Optional[str] = None,
    current_user: User = Depends(auth_service.get_current_user),
    db: Session = Depends(get_db)
):
    # Validate file type
    if file.content_type not in ["image/jpeg", "image/png", "image/gif"]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be an image (JPEG, PNG, or GIF)"
        )
    
    # Check if plant exists and belongs to user if plant_id is provided
    if plant_id:
        plant = db.query(Plant).filter(
            Plant.id == plant_id,
            Plant.owner_id == current_user.id,
            Plant.is_deleted == False
        ).first()
        
        if not plant:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
    
    # In a real app, this would upload the file to a storage service
    # and call the ML model service to diagnose the plant
    # For now, we'll create a diagnosis with mock data
    
    # Get a random plant condition for demo purposes
    plant_condition = db.query(PlantCondition).first()
    if not plant_condition:
        # Create a default plant condition if none exists
        plant_condition = PlantCondition(
            id=str(uuid.uuid4()),
            name="Healthy",
            name_ar="صحي",
            description="The plant appears to be healthy with no visible signs of disease or pest infestation.",
            description_ar="النبات يبدو صحيًا بدون علامات مرئية للمرض أو إصابة الآفات.",
            treatment="No treatment needed. Continue with regular care.",
            treatment_ar="لا يحتاج إلى علاج. استمر في الرعاية المنتظمة.",
            prevention="Maintain regular watering, appropriate light, and occasional fertilizing.",
            prevention_ar="حافظ على الري المنتظم، والضوء المناسب، والتسميد العرضي."
        )
        db.add(plant_condition)
        db.commit()
        db.refresh(plant_condition)
    
    # Create diagnosis
    diagnosis_id = str(uuid.uuid4())
    image_url = f"/uploads/diagnoses/{diagnosis_id}/{file.filename}"
    
    diagnosis = Diagnosis(
        id=diagnosis_id,
        user_id=current_user.id,
        plant_id=plant_id,
        condition_id=plant_condition.id,
        confidence_score=0.95,  # Mock confidence score
        image_url=image_url,
        notes="This is a mock diagnosis. In production, this would be generated by the ML model.",
        notes_ar="هذا تشخيص وهمي. في الإنتاج، سيتم إنشاء هذا بواسطة نموذج التعلم الآلي."
    )
    
    db.add(diagnosis)
    db.commit()
    db.refresh(diagnosis)
    
    return diagnosis

@router.get("/", response_model=List[DiagnosisResponse])
async def get_diagnoses(
    current_user: User = Depends(auth_service.get_current_user),
    plant_id: Optional[str] = None,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    # Build query
    query = db.query(Diagnosis).filter(Diagnosis.user_id == current_user.id)
    
    # Filter by plant_id if provided
    if plant_id:
        # Check if plant exists and belongs to user
        plant = db.query(Plant).filter(
            Plant.id == plant_id,
            Plant.owner_id == current_user.id,
            Plant.is_deleted == False
        ).first()
        
        if not plant:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
        
        query = query.filter(Diagnosis.plant_id == plant_id)
    
    # Get diagnoses
    diagnoses = query.order_by(Diagnosis.created_at.desc()).offset(skip).limit(limit).all()
    
    return diagnoses

@router.get("/{diagnosis_id}", response_model=DiagnosisResponse)
async def get_diagnosis(
    diagnosis_id: str,
    current_user: User = Depends(auth_service.get_current_user),
    db: Session = Depends(get_db)
):
    diagnosis = db.query(Diagnosis).filter(
        Diagnosis.id == diagnosis_id,
        Diagnosis.user_id == current_user.id
    ).first()
    
    if not diagnosis:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Diagnosis not found"
        )
    
    return diagnosis

# Plant Conditions routes (admin only)
@router.post("/conditions", response_model=PlantConditionResponse, status_code=status.HTTP_201_CREATED)
async def create_plant_condition(
    condition: PlantConditionCreate,
    current_user: User = Depends(auth_service.get_current_admin_user),
    db: Session = Depends(get_db)
):
    # Create new plant condition
    db_condition = PlantCondition(
        id=str(uuid.uuid4()),
        **condition.dict()
    )
    
    db.add(db_condition)
    db.commit()
    db.refresh(db_condition)
    
    return db_condition

@router.get("/conditions", response_model=List[PlantConditionResponse])
async def get_plant_conditions(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    conditions = db.query(PlantCondition).offset(skip).limit(limit).all()
    return conditions

@router.get("/conditions/{condition_id}", response_model=PlantConditionResponse)
async def get_plant_condition(
    condition_id: str,
    db: Session = Depends(get_db)
):
    condition = db.query(PlantCondition).filter(PlantCondition.id == condition_id).first()
    
    if not condition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant condition not found"
        )
    
    return condition